library(gRbase)
library(Rgraphviz)
ug0<-ug(~a:b,~b:c:d,~e)
plot(ug0)
dag0 <- dag(~a+b*a+c*a*b+d*c*e+e*a+g*f)
plot(dag0)
dag0
edges(dag0)
str(edges(dag0))
str(edgeList(dag0))
vpardag0<-vpar(dag0)
vpardag0$a
vpardag0$c
separates('a','d','c')
separates('a','d','c',ug0)
install.packages('lcd')
plot(ug0)
separates('a','d',c('c','b'),ug0)
myiplot <- function(x,...){
V(x)$size  <- 30
V(x)$label.cex <- 3
plot(x,...)
}
library(lcd)
library(gRbase)
library(Rgraphviz)
?separates
separates('a','d',c('c','b'),ug0)
library(RBGL)
separates('a','d',c('c','b'),ug0)
myiplot(ug0)
myiplot(dag0)
install.packages('gRim')
source("http://bioconductor.org/biocLite.R")
biocLite(c("graph", "Rgraphviz"))
library(graph)
install.packages("C:/Users/4most/Downloads/RHugin_8.0.zip", repos = NULL)
library(RHugin)
install.packages("C:/Users/4most/Downloads/RHugin_8.0.zip", repos = NULL)
library(Rhugin)
library(RHugin)
libaray(gRbase)
library(gRbase)
data(cad1,package='gRbase')
library(bnlearn)
cad.bn <- hc(cad1)
plot(as(amat(cad.bn),"graphNEL"))
cad.bn
amat(cad.bn)
install.pacakges('ggm')
install.packages('ggm')
install.packages("ggm")
library(ggm)
plot(as(essentialGraph(amat(cad.bn)),"graphNEL"))
data(carcass)
head(carcass)
?cov.wt
S.carc <- cov.wt(carcass,method='ML')$cov
head(S.carc)
cov(carcass)
K.carc <- solve(S.carc)
K.carc %*% S.carc
round(100*K.carc)
PC.carc <- cov2pcor(S.carc)
round(100*PC.carc)
sat.carc <- cmod(~.~.,data=carcass)
library(gRbase)
sat.carc <- cmod(~.~.,data=carcass)
library(gRim)
sat.carc <- cmod(~.~.,data=carcass)
sat.carc <- cmod(~.^.,data=carcass)
?cmod
sat.carc
summary(cmod)
summary(sat.carc)
str(sat.carc)
aic.carc <- stepwise(sat.carc)
library(Rgraphviz)
plot(as(aic.carc,"graphNEL"),"dfp")
plot(as(aic.carc,"graphNEL"),"fdp")
?stepwise
bic.carc <- stepwise(sat.carc,k=log(nrow(carcass)))
bic.carc
plot(as(bic.carc,"graphNEL"),"fdp")
data(BodyFat)
head(BodyFat)
BodyFat <- BodyFat[-c(31,42,48,76,86,96,159,169,175,182,206),]
BodyFat$Age <- sqrt(BodyFat$Age)
BodyFat$Weight  <- sqrt(BodyFat$Weight)
gRbodyfat <- BodyFat[,2:15]
S.body <- cov.wt(gRbodyfat,method="ML")$cov
PC.body <- cov2pcor(S.body)
round(100*PC.body)
sat.body <- cmod(~.^.,data=gRbodyfat)
bic.body <- stepwise(sat.body,k=log(nrow(gRbodyfat)))
bic.body
plot(bic.body,"neato")
plot(bic.body,"neato",shape="ellipse")
graph::degree(as(bic.body,"graphNEL"))
bic.body$varNames
str(bic.body)
bic.body$fitinfo
install.packages('glasso')
library(ggm)
gdag1 <- DAG(LeanMeat~Meat13:Fat11:Fat12,Meat13~Meat11:Meat12,Fat12~Fat11,Fat13~Meat11:Meat12,Meat12~Meat11)
plot(as(gdag1,'graphNEL'))
gdag1
fdag1 <- fitDag(gdag1,S.carc,nrow(carcass))
fdag1
library(checkpoint)
birthday<-function(n){
m<-10000
x<-numeric(m)
for(i in 1:m){
b<-sample(1:365,n,repl=T)
x[i]<-iflese(length(unique(b))==n,0,1)
}
mean(x)#estimate the prob of at least 1 match
}
for(j in 1:40) birthday(j)
birthday<-function(n){
m<-10000
x<-numeric(m)
for(i in 1:m){
b<-sample(1:365,n,repl=T)
x[i]<-ifelse(length(unique(b))==n,0,1)
}
mean(x)#estimate the prob of at least 1 match
}
for(j in 1:40) birthday(j)
library("doMC")
install.packages('doMC')
install.packages('doMC')
install.packages('foreach')
install.packages('iterators')
install.packages('doMC')
library(doMC)
install.packages("C:/Users/4most/Downloads/doMC_1.3.3.tar", repos = NULL)
install.packages("C:/Users/4most/Downloads/doMC_1.3.3.tar.gz", repos = NULL, type = "source")
install.packages('doParallel')
install.packages('doSNOW')
setwd("C:\\Projects\\BayesianNetwork\\Netscene")
require(bnlearn)
require(Rgraphviz)
require(vcd)
require(ggplot2)
require(stringr)
require(reshape)
#include the definition of the class nodes
source("C:\\Projects\\BayesianNetwork\\Netscene\\GraphRiskNode_class_z.R")
###Convert the vec to a list with name is the value of vec and element of list is also value of list
### input: vec = c("a","b")
### output:$a    $b
###        [1] a [2] b
namel<-function (vec){
tmp<-as.list(vec)
names(tmp)<-as.character(unlist(vec))
tmp
}
pn<-{}
nodes<-{}
#yn   <- c(0,1)
#decl <- seq(0.1,1.1,1)
#dech <- seq(0.1,1.1,1)
EEselNode<-1
evi_list <- list() ## should be ok if i replace << with <
result_bin<-list()
####old network starts here###
####specify the node configure
#hpi_model <- matrix(c(0.4, 0.6), ncol = 2, dimnames = list(NULL, c("LOW", "HIGH")))
#ltv_model <- list(coef = c("(Intercept)" = 2), sd = 1)
#dtv_model <- list(coef = matrix(c(1.2, 2.3, 3.4, 4.5), ncol = 2,
#                              dimnames = list(c("(Intercept)", "ltv"), NULL)),
#                sd = c(0.3, 0.6))
#vintage_model <- list(coef=c("(Intercept)"=3,"ltv"=1.6),sd=1.5)
#BoeIR_model <- matrix(c(0.5, 0.5), ncol = 2, dimnames = list(NULL, c("LOW", "HIGH")))
#IntGearing_model <- list(coef = matrix(c(-1.2, 1.1, 2, 2.6), ncol = 2,
#                              dimnames = list(c("(Intercept)", "BoeIR"), NULL)),
#                sd = c(0.13, 0.36))
#Unemp_model <- list(coef=c("(Intercept)"=0.5),sd=0.3)
#exog_model <- list(coef=c("(Intercept)"=3,"Unemp"=1.6,"IntGearing"=-0.6),sd=1.5)
#maturity_model <- matrix(c(0.7, 0.3), ncol = 2, dimnames = list(NULL, c("LOW", "HIGH")))
#DefRate_model <- list(coef = matrix(c(-1.2, 1.1, 2, -2.6), ncol = 2,
#                                  dimnames = list(c("(Intercept)", "maturity"), NULL)),
#                    sd = c(0.13, 0.36))
####note for 2 discrete nodes, we need to use 8 parameters(4 can be derived from another four)####
####wrap node configure into GRNode class, GRNode_d is for discrete node and GRNode_c is for continous node, parents,children here works
####as place holder
##hpi <- new("GRNode_d",name="hpi",model=list(model=hpi_model),values=c("LOW", "HIGH"),parents=c(NA,NA),children=c(NA,NA))
#hpi <- new("GRNode_d",name="hpi",model=list(model=hpi_model),values=colnames(hpi_model),parents=c(NA,NA),children=c(NA,NA))
#ltv <- new("GRNode_c",name="ltv",model=list(model=ltv_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
#dtv <- new("GRNode_c",name="dtv",model=list(model=dtv_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
#vintage <- new("GRNode_c",name="vintage",model=list(model=vintage_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
##BoeIR <- new("GRNode_d",name="BoeIR",model=list(model=BoeIR_model),values=c("LOW", "HIGH"),parents=c(NA,NA),children=c(NA,NA))
#BoeIR <- new("GRNode_d",name="BoeIR",model=list(model=BoeIR_model),values=colnames(BoeIR_model),parents=c(NA,NA),children=c(NA,NA))
#IntGearing <- new("GRNode_c",name="IntGearing",model=list(model=IntGearing_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
#Unemp <- new("GRNode_c",name="Unemp",model=list(model=Unemp_model),values=c(0,1),parents=c(NA,NA),children=c(NA,NA))
#exog <- new("GRNode_c",name="exog",model=list(model=exog_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
##maturity <- new("GRNode_d",name="maturity",model=list(model=maturity_model),values=c("YES","NO"),parents=c(NA,NA),children=c(NA,NA))
#maturity <- new("GRNode_d",name="maturity",model=list(model=maturity_model),values=colnames(maturity_model),parents=c(NA,NA),children=c(NA,NA))
#DefRate <- new("GRNode_c",name="DefRate",model=list(model=DefRate_model),values=c(0,1),parents=c(NA,NA),children=c(NA,NA))
###How to setup the model structure.
#networkstring <- "[hpi][ltv][dtv|hpi:ltv][vintage|ltv][BoeIR][IntGearing|BoeIR:ltv][Unemp][exog|Unemp:IntGearing][maturity][DefRate|maturity:exog]"
###old network ends here###
###specify the node configure
#hpi_model <- matrix(c(0.4, 0.6), ncol = 2, dimnames = list(NULL, c("LOW", "HIGH")))
Income_1_model <- list(coef = c("(Intercept)" = 2), sd = 1)
Inflation_1_model <- list(coef=c("(Intercept)"=3,"Income_1"=2),sd=1.5)
BoERates_1_model <- list(coef=c("(Intercept)"=3,"Income_1"=-11.6,"Inflation_1"=2.6),sd=1.5)
DTI_1_model <- list(coef=c("(Intercept)"=3,"BoERates_1"=1.6,"Income_1"=-0.6),sd=1.5)
LTV_1_model <- list(coef = c("(Intercept)" = 8), sd = 1)
Spread_1_model <- list(coef=c("(Intercept)" = 2), sd = 1)
Defaults_1_model <- list(coef=c("(Intercept)"=3,"DTI_1"=1.6,"LTV_1"=-0.6,"Spread_1"=2.2),sd=1.5)
Income_2_model <- list(coef=c("(Intercept)"=3,"BoERates_1"=2),sd=1.5)
Inflation_2_model <- list(coef=c("(Intercept)"=3,"Income_2"=2),sd=1.5)
BoERates_2_model <- list(coef=c("(Intercept)"=3,"Income_2"=1.6,"Inflation_2"=-0.6),sd=1.5)
DTI_2_model <- list(coef=c("(Intercept)"=3,"BoERates_2"=1.6,"Income_2"=-0.6),sd=1.5)
LTV_2_model <- list(coef = c("(Intercept)" = 8), sd = 1)
Spread_2_model <- list(coef=c("(Intercept)" = 2), sd = 1)
Defaults_2_model <- list(coef=c("(Intercept)"=3,"DTI_2"=1.6,"LTV_2"=-0.6,"Spread_2"=2.2),sd=1.5)
###note for 2 discrete nodes, we need to use 8 parameters(4 can be derived from another four)###
###wrap node configure into GRNode class, GRNode_d is for discrete node and GRNode_c is for continous node, parents,children here works
###as place holder
#hpi <- new("GRNode_d",name="hpi",model=list(model=hpi_model),values=c("LOW", "HIGH"),parents=c(NA,NA),children=c(NA,NA))
Income_1 <- new("GRNode_c",name="Income_1",model=list(model=Income_1_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
Inflation_1 <- new("GRNode_c",name="Inflation_1",model=list(model=Inflation_1_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
BoERates_1 <- new("GRNode_c",name="BoERates_1",model=list(model=BoERates_1_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
DTI_1 <- new("GRNode_c",name="DTI_1",model=list(model=DTI_1_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
LTV_1 <- new("GRNode_c",name="LTV_1",model=list(model=LTV_1_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
Spread_1 <- new("GRNode_c",name="Spread_1",model=list(model=Spread_1_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
Defaults_1 <- new("GRNode_c",name="Defaults_1",model=list(model=Defaults_1_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
Income_2 <- new("GRNode_c",name="Income_2",model=list(model=Income_2_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
Inflation_2 <- new("GRNode_c",name="Inflation_2",model=list(model=Inflation_2_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
BoERates_2 <- new("GRNode_c",name="BoERates_2",model=list(model=BoERates_2_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
DTI_2 <- new("GRNode_c",name="DTI_2",model=list(model=DTI_2_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
LTV_2 <- new("GRNode_c",name="LTV_2",model=list(model=LTV_2_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
Spread_2 <- new("GRNode_c",name="Spread_2",model=list(model=Spread_2_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
Defaults_2 <- new("GRNode_c",name="Defaults_2",model=list(model=Defaults_2_model),values=c(-10000,10000),parents=c(NA,NA),children=c(NA,NA))
networkstring <- "[Spread_1][LTV_1][Income_1][Inflation_1|Income_1][BoERates_1|Inflation_1:Income_1][DTI_1|Income_1:BoERates_1][Defaults_1|DTI_1:LTV_1:Spread_1]
[Income_2|BoERates_1][Inflation_2|Income_2][BoERates_2|Inflation_2:Income_2][DTI_2|Income_2:BoERates_2][Spread_2][LTV_2][Defaults_2|DTI_2:LTV_2:Spread_2]"
net <- model2network(networkstring)
###put all the GRNode into one list
nnodes <- list(Income_1,Inflation_1,BoERates_1,DTI_1,Spread_1,LTV_1,Defaults_1,Income_2,Inflation_2,BoERates_2,DTI_2,Spread_2,LTV_2,Defaults_2)
print(paste('nodes length is ',length(nnodes)))
###build the network###
cgfit <- fit.net.z(nnodes,net)
###get all names for every node###
node_names <- get.name(nnodes)
print(paste0('the name of list from get name method is ',node_names))
###query the network###
#cpquery(cgfit, (maturity=="YES"), TRUE)
#bin=0.1
#b<-cpdist(cgfit, "DefRate",(maturity=="NO")&(Unemp>0.1)&(Unemp<0.12))
#plot(density(b$DefRate))
#mean(b$DefRate)
## [1] -22.44305
#plot(density(b$DefRate))
ddd<-rbn(cgfit,n=2000)
target <- 'Defaults_2'
minV <- 1.03
maxV <- 4.34
get.parents.by.childname=function(child){
pnodes <-vector()
pnodes <- cgfit[[child]]$parents
pnodes
}
get.name.reactive<-reactive({
var.opts <- namel(colnames(ddd)) ##update here at 15:23
if(input$CreateNode){
var.opts <- namel(colnames(ddd))
}
#    var.opts <- namel(get.name(nnodes))
#    print(paste0('in get name reactive, nodes are ',get.name(nnodes)))
var.opts
})
require(shiny)
get.name.reactive<-reactive({
var.opts <- namel(colnames(ddd)) ##update here at 15:23
if(input$CreateNode){
var.opts <- namel(colnames(ddd))
}
#    var.opts <- namel(get.name(nnodes))
#    print(paste0('in get name reactive, nodes are ',get.name(nnodes)))
var.opts
})
get.name.reactive<-reactive({
var.opts <- namel(colnames(ddd)) ##update here at 15:23
if(input$CreateNode){
var.opts <- namel(colnames(ddd))
}
#    var.opts <- namel(get.name(nnodes))
#    print(paste0('in get name reactive, nodes are ',get.name(nnodes)))
var.opts
})
allNames <- get.name.reactive()
setwd('C:\\Projects\\BayesianNetwork\\Netscene')
library(shiny)
runApp()
allNames <- get.name.reactive()
allNames <- namel(colnames(ddd))
allNames
allNames[[target]] <- NUL
allNames[[target]] <- NULL
allNames
child_parents_list <- list()
for(i in allButOne){
parents<-get.parents.by.childname(i)
if(length(parents)>0){
child_parents_list[[i]] <- parents
}
}
allButOne <- unlist(lapply(allNames,function(x) x[[1]]))
allButOne
unname(allButOne)
allButOne <- unname(allButOne)
allButOne
child_parents_list <- list()
for(i in allButOne){
parents<-get.parents.by.childname(i)
if(length(parents)>0){
child_parents_list[[i]] <- parents
}
}
visit_list<-list()
best_conf<-list()
inference_from_child <- list()
evi_string <- paste0('(',target,'>',minV,'&',target,'<',maxV,')')
querynodes <- paste(allButOne,collapse = '","')
eval_string <- paste0('cpdist(cgfit,c("',querynodes,'"),',evi_string,')')
print('in best conf')
print(eval_string)
result <- eval(parse(text=eval_string))
print(head(result))
result_bin<<-lapply(result[,colnames(result) %in% get.parents.by.childname(target)],function(x) cut(x,ifelse((diff(range(x))/10)>1,round(diff(range(x)),0),10)))
result_bin_full<-lapply(result,function(x) cut(x,ifelse((diff(range(x))/10)>1,round(diff(range(x)),0),10)))
result_bin_df_full <- as.data.frame(result_bin_full)
result_bin_df <- result_bin_df_full
result_bin_df <- result_bin_df[,colnames(result_bin_df) %in% get.parents.by.childname(target)]
result_count_df <- as.data.frame(table(result_bin_df))
print(head(result_count_df))
bestConfName <- colnames(result_bin_df)
bestSet <- result_count_df[which.max(result_count_df$Freq),]
for(i in bestConfName){
if(i!='Freq'&&!(i %in% visit_list)){
visit_list[[length(visit_list)+1]] <- i
#			best_conf[[length(best_conf)+1]] <- as.character(bestSet[[i]])
parents <- get.parents.by.childname(i)
if(length(parents)>0){
inference_from_child[[length(inference_from_child)+1]] <- i ##the next search start from i
}
}
}#
total <- 0
inference_from_child
inference_from_child_bak <- inference_from_child##copy by value, not reference???
print(inference_from_child)
print('*****************')
for(ii in 1:length(inference_from_child_bak)){#get a candidate node
seed_node <- inference_from_child_bak[[ii]]
print(paste0('@@@ processing seed node :',seed_node))
remove_index <- -1
for(i in 1:length(inference_from_child)){#update the candidate list pool to remove the selected node.
if(inference_from_child[[i]]==seed_node){
remove_index <- i
}
}
if(remove_index>0){
inference_from_child[[remove_index]] <- NULL
}
parents <- child_parents_list[[seed_node]]
interested_parents <- parents
result_bin_df <- result_bin_df_full
if(!all(parents %in% visit_list)){
for(p in parents){
if(p %in% visit_list){
interested_parents <- interested_parents[!interested_parents %in% p]#if parent is in visited list, add it to constraints and remove from interested parents node
print(p)
result_bin_df <- subset(result_bin_df,result_bin_df[,p]==best_conf[[p]])
}
}
result_bin_df <- subset(result_bin_df,result_bin_df[,seed_node]==best_conf[[seed_node]])##this can be problematic
result_bin_df <- subset(result_bin_df,select = interested_parents)#result_bin_df[,interested_parents] it drop the data frame format
print(paste0('$$$ inference parent nodes:',as.character(interested_parents)))
result_count_df <- as.data.frame(table(result_bin_df))
bestConfName <- colnames(result_bin_df)
bestSet <- result_count_df[which.max(result_count_df$Freq),]
index <- 1
for(j in bestConfName){
if(j!='Freq'&&!(j %in% visit_list)){
visit_list[[length(visit_list)+1]] <- j
#				best_conf[[length(best_conf)+1]] <- as.character(bestSet[[i]])
if(!is.null(bestSet[[j]])){#2 or more ways table
best_conf[[j]] <- as.character(bestSet[[j]])
}else{#1 way table
best_conf[[j]] <- as.character(bestSet[,index])
index <- index + 1
}
parents <- get.parents.by.childname(j)
if(length(parents)>0&&!all(parents %in% visit_list)){
inference_from_child[[length(inference_from_child)+1]] <- j ##the next search start from j
}
}
}
}
}
inference_from_child
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
a<-list()
length(a)
runApp()
runApp()
runApp()
runApp()
